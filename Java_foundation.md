## 基础概念与常识

### Java 语言特点？

1. 面向对象（封装，继承，多态）；
2. 平台无关性（ Java 虚拟机实现平台无关性）；
3. 支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）；
4. 可靠性；安全性；
5. 支持**网络编程**并且很方便（ Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便）；
6. 编译与解释并存；

> **🐛 修正（参见： [issue#544](https://github.com/Snailclimb/JavaGuide/issues/544)）** ：C++11 开始（2011 年的时候）,C++就引入了多线程库，在 windows、linux、macos 都可以使用`std::thread`和`std::async`来创建线程。参考链接：http://www.cplusplus.com/reference/thread/thread/?kw=thread

实际上，跨平台已经不是 Java 最大的卖点了，各种 JDK 新特性也不是。目前市面上虚拟化技术已经非常成熟，比如你**通过 Docker 就很容易实现跨平台了**。在我看来，Java 强大的生态才是！

### JVM vs JDK vs JRE

<img src="E:\面试\pic\JDK.png" style="zoom:75%;" />

- 运行安装 JRE
- 编程安装 JDK

> 但是，这不是绝对的。有时，即使您不打算在计算机上进行任何 Java 开发，仍然需要安装 JDK。例如，如果要使用 JSP 部署 Web 应用程序，那么从技术上讲，您只是在应用程序服务器中运行 Java 程序。那你为什么需要 JDK 呢？因为应用程序服务器会将 JSP 转换为 Java servlet，并且需要使用 JDK 来编译 servlet。

#### JVM

Java 虚拟机（JVM）是**运行 Java 字节码**的虚拟机。

- JVM 针对不同系统（Windows，Linux，macOS）有特定实现
- **使用相同的字节码，它们都会给出相同的结果**。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。
- **只要满足 JVM 规范，每个公司、组织或者个人都可以开发自己的专属 JVM。** 平时接触到的 HotSpot VM 仅仅是是 JVM 规范的一种实现而已。

> 除了我们平时最常用的 HotSpot VM 外，还有 J9 VM、Zing VM、JRockit VM 等 JVM 。维基百科上就有常见 JVM 的对比：[Comparison of Java virtual machines](https://en.wikipedia.org/wiki/Comparison_of_Java_virtual_machines) 

####  JRE

JRE 是 **Java 运行时环境**。它是运行已编译 Java 程序所需的所有内容的集合，**包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件**。但是，它不能用于创建新程序。

#### JDK

JDK 是 **Java Development Kit** 缩写，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。

### 什么是字节码?采用字节码的好处是什么?

在 Java 中，**JVM 可以理解的代码就叫做字节码**（即扩展名为 `.class` 的文件），它不面向任何特定的处理器，只面向虚拟机。

1. 一定程度上解决了**传统解释型语言执行效率低**的问题，同时又保留了**解释型语言可移植**的特点。所以， **Java 程序运行时相对来说还是高效**的（不过，和 C++，Rust，Go 等语言还是有一定差距的），
2. 由于字节码并不针对一种特定的机器，因此，Java 程序**无须重新编译便可在多种不同操作系统的计算机上运行**。

**Java 程序从源代码到运行的过程如下图所示：**

![Java程序转变为机器代码的过程](E:\面试\JavaGuide\docs\java\basis\images\java程序转变为机器代码的过程.png)

### JAVA中堆与栈

 **Java把内存划分成两种：一种是栈内存，一种是堆内存**。

JVM是基于堆栈的虚拟机，堆和栈都是Java用来在内存中存放数据的地方。

#### 功能和作用：

**堆主要用来存放对象的，栈主要是用来执行程序的。**

（1）栈，方法的运行模型，通过栈帧来调用，**JVM会为每个线程都分配一个栈区**，JVM对栈只进行两种操作：以帧为单位的**压栈和出栈操作**。当线程进入一个Java方法函数的时候，就会在当前线程的栈里压入一个栈帧，用于保存当前线程的状态（参数、局部变量、中间计算过程和其他数据），当退出函数方法时，修改栈指针就可以把栈中的内容销毁。

（2）堆，唯一的目的就是用于**存放对象实例**，每个Java应用都唯一对应一个JVM实例，每个JVM实例都唯一对应一个堆，并由堆内存被应用所有的线程共享。

#### 程序运行时的内存分配的三种策略：**静态的,栈式的,和堆式的**

**（1）静态存储分配**：编译时能知道所有变量的存储要求，分配固定的内存空间。

代码中**不允许有可变数据结构**，**不允许有嵌套或者递归**

**（2）栈式存储分配**：也可称为**动态存储分配**，**过程的入口处**必须知道所有的存储要求

由一个类似于堆栈的运行栈实现。进入程序模块时，必须知道数据区大小。按照**先进后出的原则**分配。

**（3）堆式存储分配**：**可变长度串和对象实例**

无法确定存储要求的内存分配**。**堆由大片的可利用块或空闲块组成，内存按照任意顺序分配和释放。

#### 性能与存储要求：

（1）**栈的性能比堆要快**，仅次于位于CPU中的寄存器。但是，在分配内存的时候，存放在栈中的数据大小与生存周期必须在编译时是确定的，**缺乏灵活性**。

（2）**堆可以动态分配内存大小**，编译器不必知道要从堆里分配多少存储空间，生存周期也不必事先告诉编译器，Java的垃圾收集器会自动收走这些不再使用的数据，因此可以得到**更大的灵活性**。但是，由于要在运行时动态分配内存和销毁对象时都需要占用时间，所以**效率低**。由于面向对象的多态性，堆内存分配是必不可少的，因为多态变量所需的存储空间只有在运行时创建了对象之后才能确定。当然，为达到这种灵活性，必然会付出一定的代价。

#### 内存的分配与回收：

跟C/C++不同，Java中分配**堆栈内存是由JVM自动分配和管理的。**

Java中的数据类型有两种：一种是8个基本类型（即int, short, long, byte, float, double, boolean, char），一种是引用类型。

（1）函数中基本类型和对象的引用都是在栈内存中分配。当在一段代码块中定义一个变量时，由于这些变量大小可知，生存期可知，出于追求速度的原因，Java就在栈中为这个变量分配内存空间，当超过变量的作用域后，Java会自动释放掉为该变量所分配的内存空间。

（2）对于引用类型：Java中所有对象的存储空间都是在堆中分配的，但是这个对象的引用却是在堆栈中分配。也就是说在建立一个对象时，从两个地方都分配内存，在堆中分配的内存实际用于建立这个对象，而在栈中分配的内存只是一个指向这个堆对象的引用而已。在堆中分配的内存，由Java虚拟机的自动垃圾回收器来管理。

4、内存共享：

（1）栈数据的内存共享：

假设我们同时定义：int a = 3; int b = 3；编译器先处理int a = 3；首先它会在栈中创建一个变量为a的引用，然后查找有没有字面值为3的地址，没找到，就开辟一个存放3这个字面值的地址，然后将a指向3的地址。接着处理int b = 3；在创建完b的引用变量后，由于在栈中已经有3这个字面值，便将b直接指向3的地址。这样，就出现了a与b同时均指向3的情况。

这种字面值的引用与类对象的引用不同。假定两个类对象的引用同时指向一个对象，如果一个对象引用变量修改了这个对象的内部状态，那么另一个对象引用变量也即刻反映出这个变化。相反，通过字面值的引用来修改其值，不会导致另一个指向此字面值的引用的值也跟着改变的情况。

如上例，我们定义完a与 b的值后，再令a=4；那么，b不会等于4，还是等于3。在编译器内部，遇到a=4时，它就会重新搜索栈中是否有4的字面值，如果没有，重新开辟地址存放4的值；如果已经有了，则直接将a指向这个地址。因此a值的改变不会影响到b的值。

（2）引用类型的内存共享：

String类型用String str = new String("abc")的形式来创建，也可以用String str = "abc"的形式来创建。前者是规范的类的创建过程，即在Java中，一切都是对象，而对象是类的实例，全部通过new()的形式来创建。那为什么在String str = "abc"；中，并没有通过new()来创建实例，是不是违反了上述原则？其实没有：

关于String str = "abc"的内部工作。Java内部将此语句转化为以下几个步骤：

（1）先定义一个名为str对象引用变量：String str；

（2）在栈中查找有没有存放值为"abc"的地址，如果没有，则开辟一个存放字面值为"abc"的地址，接着创建一个新的String类的对象o，并将o 的字符串值指向这个地址，而且在栈中这个地址旁边记下这个引用的对象o。如果已经有了值为"abc"的地址，则查找对象o，并返回o的地址。

（3）将str指向对象o的地址。

值得注意的是，一般String类中字符串值都是直接存值的。但像String str = "abc"；这种场合下，其字符串值却是保存了一个指向存在栈中数据的引用！ 为了更好地说明这个问题，我们可以通过以下的几个代码进行验证。

String str1 = "abc"; String str2 = "abc";

System.out.println(str1==str2); //true

 注意，我们这里并不用str1.equals(str2)；的方式，因为这将比较两个字符串的值是否相等。而我们在这里要看的是，str1与str2是否都指向了同一个对象，==号只有在两个引用都指向了同一个对象时才返回真值。 结果说明，JVM创建了两个引用str1和str2，但只创建了一个对象，而且两个引用都指向了这个对象。 我们再来更进一步，将以上代码改成：

String str1 = "abc";

String str2 = "abc";

str1 = "bcd";

System.out.println(str1 + "," + str2); //bcd, abc

System.out.println(str1==str2); //false

这就是说，赋值的变化导致了类对象引用的变化，str1指向了另外一个新对象！而str2仍旧指向原来的对象。上例中，当我们将str1的值改为"bcd"时，JVM发现在栈中没有存放该值的地址，便开辟了这个地址，并创建了一个新的对象，其字符串的值指向这个地址。

事实上，String类被设计成为不可改变(immutable)的类。如果你要改变其值，可以，但JVM在运行时根据新值悄悄创建了一个新对象，然后将这个对象的地址返回给原来类的引用。这个创建过程虽说是完全自动进行的，但它毕竟占用了更多的时间。在对时间要求比较敏感的环境中，会带有一定的不良影响。 再修改原来代码：

String str1 = "abc";

String str2 = "abc";

str1 = "bcd";

String str3 = str1;

System.out.println(str3); //bcd

String str4 = "bcd";

System.out.println(str1 == str4); //true

str3 这个对象的引用直接指向str1所指向的对象(注意，str3并没有创建新对象)。当str1改完其值后，再创建一个String的引用str4，并指向因str1修改值而创建的新的对象。可以发现，这回str4也没有创建新的对象，从而再次实现栈中数据的共享。

我们再接着看以下的代码：

String str1 = new String("abc");

String str2 = "abc";

System.out.println(str1==str2); //false

创建了两个引用。创建了两个对象。两个引用分别指向不同的两个对象。

String str1 = "abc";

String str2 = new String("abc");

 System.out.println(str1==str2); //false

创建了两个引用。创建了两个对象。两个引用分别指向不同的两个对象。 以上两段代码说明，只要是用new()来新建对象的，都会在堆中创建，而且其字符串是单独存值的，即使与栈中的数据相同，也不会与栈中的数据共享。

综上：

（1）我们在使用诸如 String str = "abc" 的格式定义类时，对象可能并没有被创建。唯一可以肯定的是，指向 String类的引用被创建了，至于这个引用到底是否指向了一个新的对象，必须根据上下文来考虑，除非通过new()方法来显式地创建一个新的对象。

（2）使用 String str = "abc" 的方式，可以在一定程度上提高程序的运行速度，因为JVM会自动根据栈中数据的实际情况来决定是否有必要创建新对象，这是享元模式的思想。而对于String str = new String("abc")；的代码，则一概在堆中创建新对象，而不管其字符串值是否相等，是否有必要创建新对象，从而加重了程序的负担。
————————————————

[]: 原文链接：https://blog.csdn.net/a745233700/article/details/89228381



### Java 和 C++ 的区别?

Java 和 C++ **都是面向对象的语言**，都**支持封装、继承和多态**

不相同的地方：

- Java **不提供指针来直接访问内存**，程序内存更加安全
- Java 的类是单继承的，C++ 支持多重继承；虽然 **Java 的类不可以多继承，但是接口可以多继承**。
- Java 有**自动内存管理垃圾回收机制**(GC)，不需要程序员手动释放无用内存。
- C ++同时支持方法重载和操作符重载，但是 **Java 只支持方法重载**（操作符重载增加了复杂性，这与 Java 最初的设计思想不符）。

#### 静态方法为什么不能调用非静态成员?

这个需要结合 JVM 的相关知识，主要原因如下：

1. **静态方法是属于类的**，在类加载的时候就会分配内存，可以通过类名直接访问。而**非静态成员属于实例对象**，只有在对象实例化之后才存在，需要通过类的实例对象去访问。
2. 在类的非静态成员不存在的时候静态成员就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。

#### 静态方法和实例方法有何不同？

**1、调用方式**

在外部调用静态方法时，可以使用 `类名.方法名` 的方式，也可以使用 `对象.方法名` 的方式，而实例方法只有后面这种方式。也就是说，**调用静态方法可以无需创建对象** 。

> 一般建议使用 `类名.方法名` 的方式来调用静态方法。
>
> 一般不建议使用 `对象.方法名` 的方式来调用静态方法。这种方式非常容易造成混淆，静态方法不属于类的某个对象而是属于这个类。

**2、访问类成员是否存在限制**

**静态方法**在访问本类的成员时，**只允许访问静态成员（即静态成员变量和静态方法）**，不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制。

#### 重载和重写的区别

> 重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理
>
> 重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法

**重载**

发生在同一个类中（或者父类和子类之间），方法名必须相同，**参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同**。

**重写**

重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。

1. 方法名、参数列表必须相同，子类方法**返回值类型应比父类方法返回值类型更小或相等**，抛出的异常范围小于等于父类，**访问修饰符范围大于等于父**类。
2. 如果父类方法访问修饰符为 `private/final/static` 则子类就不能重写该方法，但是被 `static` 修饰的方法能够被再次声明。
3. 构造方法无法被重写

**方法的重写要遵循“两同两小一大”**（以下内容摘录自《疯狂 Java 讲义》，[issue#892](https://github.com/Snailclimb/JavaGuide/issues/892) ）：

- “两同”即**方法名相同、形参列表**相同；
- “两小”指的是子类方法**返回值类型应比父类方法返回值类型更小或相等**，子类方法声明抛出的**异常类应比父类方法声明抛出的异常类更小或相等**；
- “一大”指的是子类方法的**访问权限应比父类方法的访问权限更大或相等。**

### 可变长参数？

允许在调用方法时传入不定长度的参数。方法就可以接受 0 个或者多个参数。

1. 另外，可变参数**只能作为函数的最后一个参数**，但其前面可以有也可以没有任何其他参数。
2. **方法重载先匹配固定参数的方法**，因为固定参数的方法匹配度更高。

```java
public static void method2(String arg1, String... args) {
   //......
}
```

## 基本数据类型

### Java 中的几种基本数据类型了解么？

Java 中有 8 种基本数据类型，分别为：

- 6 种数字类型：
  - 4 种整数型：`byte`、`short`、`int`、`long`
  - 2 种浮点型：`float`、`double`
- 1 种字符类型：`char`
- 1 种布尔型：`boolean`。

这 8 种基本数据类型的默认值以及所占空间的大小如下：

| 基本类型  | 位数 | 字节 | 默认值  | 取值范围                                   |
| :-------- | :--- | :--- | :------ | ------------------------------------------ |
| `byte`    | 8    | 1    | 0       | -128 ~ 127                                 |
| `short`   | 16   | 2    | 0       | -32768 ~ 32767                             |
| `int`     | 32   | 4    | 0       | -2147483648 ~ 2147483647                   |
| `long`    | 64   | 8    | 0L      | -9223372036854775808 ~ 9223372036854775807 |
| `char`    | 16   | 2    | 'u0000' | 0 ~ 65535                                  |
| `float`   | 32   | 4    | 0f      | 1.4E-45 ~ 3.4028235E38                     |
| `double`  | 64   | 8    | 0d      | 4.9E-324 ~ 1.7976931348623157E308          |
| `boolean` | 1    |      | false   | true、false                                |

对于 `boolean`，官方文档未明确定义，它依赖于 JVM 厂商的具体实现。逻辑上理解是占用 1 位，但是实际中会考虑计算机高效存储因素。

另外，Java 的每种**基本类型所占存储空间的大小**不会像其他大多数语言那样随机器硬件架构的变化而变化。这种所占存储空间大小的不变性是 Java 程序比用其他大多数语言编写的程序更具可移植性的原因之一（《Java 编程思想》2.2 节有提到）。

**注意：**

1. Java 里使用 `long` 类型的数据一定要在数值后面加上 **L**，否则将作为整型解析。
2. `char a = 'h'`char :单引号，`String a = "hello"` :双引号。

这八种基本类型对应的包装类分别为：`Byte`、`Short`、`Integer`、`Long`、`Float`、`Double`、`Character`、`Boolean` 。

### 基本类型和包装类型的区别？

- **包装类型不赋值就是 `null`** ，而基本类型有默认值且不是 `null`。
- **包装类型可用于泛型**，而基本类型不可以。
- 基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 `static` 修饰 ）存放在 Java 虚拟机的堆中。**包装类型属于对象类型**，我们知道**几乎所有对象实例都存在于堆中。**
- 相比于对象类型， **基本数据类型占用的空间非常小**。

### 包装类型的常量池技术了解么？

Java 基本类型的包装类的大部分都实现了常量池技术。

- `Byte`,`Short`,`Integer`,`Long` 这 4 种包装类默认创建了数值 **[-128，127]** 的**相应类型的缓存数据**，`Character` 创建了数值在 **[0,127]** 范围的缓存数据，`Boolean` 直接返回 `True` or `False`。
- 有缓存返回IntegerCache.cache，没有就返回new Integer()
- 超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。


两种**浮点数类型的包装类 `Float`,`Double` 并没有实现常量池技术**。

**所有整型包装类对象之间值的比较，全部使用 equals 方法比较**。

### 自动装箱与拆箱了解吗？原理是什么？

**什么是自动拆装箱？**

- **装箱**：将基本类型用它们对应的引用类型包装起来；
- **拆箱**：将包装类型转换为基本数据类型；

装箱其实就是调用了 包装类的`valueOf()`方法，拆箱其实就是调用了 `xxxValue()`方法。

- `Integer i = 10` 等价于 `Integer i = Integer.valueOf(10)`
- `int n = i` 等价于 `int n = i.intValue()`;

**频繁拆装箱的话，会严重影响系统的性能。应避免不必要的拆装箱操作。**



## 面向对象基础

### 面向对象和面向过程的区别

两者的主要区别在于解决问题的方式不同：

- 面向过程把解决问题的**过程拆成一个个方法**，通过一个个方法的执行解决问题。
- 面向对象会先**抽象出对象，然后用对象执行方法**的方式解决问题。

另外，**面向对象开发的程序一般更易维护、易复用、易扩展。**

### 成员变量与局部变量的区别有哪些？

- **语法形式** ：从语法形式上看，**成员变量是属于类**的，而局部变量是在代码块或方法中定义的变量或是方法的参数；**成员变量可以被 `public`,`private`,`static` 等修饰符所修饰**，而局部变量不能被访问控制修饰符及 `static` 所修饰；但是，**成员变量和局部变量都能被 `final` 所修饰**。
- **存储方式** ：从变量在内存中的存储方式来看,如果成员变量是使用 `static` 修饰的，那么这个成员变量是属于类的，如果没有使用 `static` 修饰，这个成员变量是属于实例的。而**对象存在于堆内存，局部变量则存在于栈内存**。
- **生存时间** ：从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡。
- **默认值** ：从变量是否有默认值来看，**成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值**（一种情况例外:被 `final` 修饰的成员变量也必须显式地赋值），而**局部变量则不会自动赋值。**

###  
