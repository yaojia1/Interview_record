## 基础概念与常识

### Java 语言特点？

1. 面向对象（封装，继承，多态）；
2. 平台无关性（ Java 虚拟机实现平台无关性）；
3. 支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）；
4. 可靠性；安全性；
5. 支持**网络编程**并且很方便（ Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便）；
6. 编译与解释并存；

> **🐛 修正（参见： [issue#544](https://github.com/Snailclimb/JavaGuide/issues/544)）** ：C++11 开始（2011 年的时候）,C++就引入了多线程库，在 windows、linux、macos 都可以使用`std::thread`和`std::async`来创建线程。参考链接：http://www.cplusplus.com/reference/thread/thread/?kw=thread

实际上，跨平台已经不是 Java 最大的卖点了，各种 JDK 新特性也不是。目前市面上虚拟化技术已经非常成熟，比如你**通过 Docker 就很容易实现跨平台了**。在我看来，Java 强大的生态才是！

### JVM vs JDK vs JRE

<img src="E:\面试\pic\JDK.png" style="zoom:75%;" />

- 运行安装 JRE
- 编程安装 JDK

> 但是，这不是绝对的。有时，即使您不打算在计算机上进行任何 Java 开发，仍然需要安装 JDK。例如，如果要使用 JSP 部署 Web 应用程序，那么从技术上讲，您只是在应用程序服务器中运行 Java 程序。那你为什么需要 JDK 呢？因为应用程序服务器会将 JSP 转换为 Java servlet，并且需要使用 JDK 来编译 servlet。

#### JVM

Java 虚拟机（JVM）是**运行 Java 字节码**的虚拟机。

- JVM 针对不同系统（Windows，Linux，macOS）有特定实现
- **使用相同的字节码，它们都会给出相同的结果**。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。
- **只要满足 JVM 规范，每个公司、组织或者个人都可以开发自己的专属 JVM。** 平时接触到的 HotSpot VM 仅仅是是 JVM 规范的一种实现而已。

> 除了我们平时最常用的 HotSpot VM 外，还有 J9 VM、Zing VM、JRockit VM 等 JVM 。维基百科上就有常见 JVM 的对比：[Comparison of Java virtual machines](https://en.wikipedia.org/wiki/Comparison_of_Java_virtual_machines) 

####  JRE

JRE 是 **Java 运行时环境**。它是运行已编译 Java 程序所需的所有内容的集合，**包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件**。但是，它不能用于创建新程序。

#### JDK

JDK 是 **Java Development Kit** 缩写，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。

### 什么是字节码?采用字节码的好处是什么?

在 Java 中，**JVM 可以理解的代码就叫做字节码**（即扩展名为 `.class` 的文件），它不面向任何特定的处理器，只面向虚拟机。

1. 一定程度上解决了**传统解释型语言执行效率低**的问题，同时又保留了**解释型语言可移植**的特点。所以， **Java 程序运行时相对来说还是高效**的（不过，和 C++，Rust，Go 等语言还是有一定差距的），
2. 由于字节码并不针对一种特定的机器，因此，Java 程序**无须重新编译便可在多种不同操作系统的计算机上运行**。

**Java 程序从源代码到运行的过程如下图所示：**

![Java程序转变为机器代码的过程](E:\面试\JavaGuide\docs\java\basis\images\java程序转变为机器代码的过程.png)

### Java 和 C++ 的区别?

Java 和 C++ **都是面向对象的语言**，都**支持封装、继承和多态**

不相同的地方：

- Java **不提供指针来直接访问内存**，程序内存更加安全
- Java 的类是单继承的，C++ 支持多重继承；虽然 **Java 的类不可以多继承，但是接口可以多继承**。
- Java 有**自动内存管理垃圾回收机制**(GC)，不需要程序员手动释放无用内存。
- C ++同时支持方法重载和操作符重载，但是 **Java 只支持方法重载**（操作符重载增加了复杂性，这与 Java 最初的设计思想不符）。

#### 静态方法为什么不能调用非静态成员?

这个需要结合 JVM 的相关知识，主要原因如下：

1. **静态方法是属于类的**，在类加载的时候就会分配内存，可以通过类名直接访问。而**非静态成员属于实例对象**，只有在对象实例化之后才存在，需要通过类的实例对象去访问。
2. 在类的非静态成员不存在的时候静态成员就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。

#### 静态方法和实例方法有何不同？

**1、调用方式**

在外部调用静态方法时，可以使用 `类名.方法名` 的方式，也可以使用 `对象.方法名` 的方式，而实例方法只有后面这种方式。也就是说，**调用静态方法可以无需创建对象** 。

> 一般建议使用 `类名.方法名` 的方式来调用静态方法。
>
> 一般不建议使用 `对象.方法名` 的方式来调用静态方法。这种方式非常容易造成混淆，静态方法不属于类的某个对象而是属于这个类。

**2、访问类成员是否存在限制**

**静态方法**在访问本类的成员时，**只允许访问静态成员（即静态成员变量和静态方法）**，不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制。

#### 重载和重写的区别

> 重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理
>
> 重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法

**重载**

发生在同一个类中（或者父类和子类之间），方法名必须相同，**参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同**。

**重写**

重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。

1. 方法名、参数列表必须相同，子类方法**返回值类型应比父类方法返回值类型更小或相等**，抛出的异常范围小于等于父类，**访问修饰符范围大于等于父**类。
2. 如果父类方法访问修饰符为 `private/final/static` 则子类就不能重写该方法，但是被 `static` 修饰的方法能够被再次声明。
3. 构造方法无法被重写

**方法的重写要遵循“两同两小一大”**（以下内容摘录自《疯狂 Java 讲义》，[issue#892](https://github.com/Snailclimb/JavaGuide/issues/892) ）：

- “两同”即**方法名相同、形参列表**相同；
- “两小”指的是子类方法**返回值类型应比父类方法返回值类型更小或相等**，子类方法声明抛出的**异常类应比父类方法声明抛出的异常类更小或相等**；
- “一大”指的是子类方法的**访问权限应比父类方法的访问权限更大或相等。**

### 可变长参数？

允许在调用方法时传入不定长度的参数。方法就可以接受 0 个或者多个参数。

1. 另外，可变参数**只能作为函数的最后一个参数**，但其前面可以有也可以没有任何其他参数。
2. **方法重载先匹配固定参数的方法**，因为固定参数的方法匹配度更高。

```java
public static void method2(String arg1, String... args) {
   //......
}
```

## 基本数据类型

### Java 中的几种基本数据类型了解么？

Java 中有 8 种基本数据类型，分别为：

- 6 种数字类型：
  - 4 种整数型：`byte`、`short`、`int`、`long`
  - 2 种浮点型：`float`、`double`
- 1 种字符类型：`char`
- 1 种布尔型：`boolean`。

这 8 种基本数据类型的默认值以及所占空间的大小如下：

| 基本类型  | 位数 | 字节 | 默认值  | 取值范围                                   |
| :-------- | :--- | :--- | :------ | ------------------------------------------ |
| `byte`    | 8    | 1    | 0       | -128 ~ 127                                 |
| `short`   | 16   | 2    | 0       | -32768 ~ 32767                             |
| `int`     | 32   | 4    | 0       | -2147483648 ~ 2147483647                   |
| `long`    | 64   | 8    | 0L      | -9223372036854775808 ~ 9223372036854775807 |
| `char`    | 16   | 2    | 'u0000' | 0 ~ 65535                                  |
| `float`   | 32   | 4    | 0f      | 1.4E-45 ~ 3.4028235E38                     |
| `double`  | 64   | 8    | 0d      | 4.9E-324 ~ 1.7976931348623157E308          |
| `boolean` | 1    |      | false   | true、false                                |

对于 `boolean`，官方文档未明确定义，它依赖于 JVM 厂商的具体实现。逻辑上理解是占用 1 位，但是实际中会考虑计算机高效存储因素。

另外，Java 的每种**基本类型所占存储空间的大小**不会像其他大多数语言那样随机器硬件架构的变化而变化。这种所占存储空间大小的不变性是 Java 程序比用其他大多数语言编写的程序更具可移植性的原因之一（《Java 编程思想》2.2 节有提到）。

**注意：**

1. Java 里使用 `long` 类型的数据一定要在数值后面加上 **L**，否则将作为整型解析。
2. `char a = 'h'`char :单引号，`String a = "hello"` :双引号。

这八种基本类型对应的包装类分别为：`Byte`、`Short`、`Integer`、`Long`、`Float`、`Double`、`Character`、`Boolean` 。

### 基本类型和包装类型的区别？

- **包装类型不赋值就是 `null`** ，而基本类型有默认值且不是 `null`。
- **包装类型可用于泛型**，而基本类型不可以。
- 基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 `static` 修饰 ）存放在 Java 虚拟机的堆中。**包装类型属于对象类型**，我们知道**几乎所有对象实例都存在于堆中。**
- 相比于对象类型， **基本数据类型占用的空间非常小**。

### 包装类型的常量池技术了解么？

Java 基本类型的包装类的大部分都实现了常量池技术。

- `Byte`,`Short`,`Integer`,`Long` 这 4 种包装类默认创建了数值 **[-128，127]** 的**相应类型的缓存数据**，`Character` 创建了数值在 **[0,127]** 范围的缓存数据，`Boolean` 直接返回 `True` or `False`。
- 有缓存返回IntegerCache.cache，没有就返回new Integer()
- 超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。


两种**浮点数类型的包装类 `Float`,`Double` 并没有实现常量池技术**。

**所有整型包装类对象之间值的比较，全部使用 equals 方法比较**。

### 自动装箱与拆箱了解吗？原理是什么？

**什么是自动拆装箱？**

- **装箱**：将基本类型用它们对应的引用类型包装起来；
- **拆箱**：将包装类型转换为基本数据类型；

装箱其实就是调用了 包装类的`valueOf()`方法，拆箱其实就是调用了 `xxxValue()`方法。

- `Integer i = 10` 等价于 `Integer i = Integer.valueOf(10)`
- `int n = i` 等价于 `int n = i.intValue()`;

**频繁拆装箱的话，会严重影响系统的性能。应避免不必要的拆装箱操作。**

## 面向对象基础

### 面向对象和面向过程的区别

两者的主要区别在于解决问题的方式不同：

- 面向过程把解决问题的**过程拆成一个个方法**，通过一个个方法的执行解决问题。
- 面向对象会先**抽象出对象，然后用对象执行方法**的方式解决问题。

另外，**面向对象开发的程序一般更易维护、易复用、易扩展。**
